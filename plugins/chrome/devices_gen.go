//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"io"
	"net/http"
	"os"
	"regexp"
	"strings"
)

const deviceDescriptorsURL = "https://raw.githubusercontent.com/puppeteer/puppeteer/main/packages/puppeteer-core/src/common/Device.ts"

func main() {
	out := flag.String("out", "devices.go", "out")
	flag.Parse()
	if err := run(*out); err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

type deviceDescriptor struct {
	Name      string `json:"name"`
	UserAgent string `json:"userAgent"`
	Viewport  struct {
		Width             int64   `json:"width"`
		Height            int64   `json:"height"`
		DeviceScaleFactor float64 `json:"deviceScaleFactor"`
		IsMobile          bool    `json:"isMobile"`
		HasTouch          bool    `json:"hasTouch"`
		IsLandscape       bool    `json:"isLandscape"`
	} `json:"viewport"`
}

var cleanRE = regexp.MustCompile(`[^a-zA-Z0-9_]`)

// run runs the program.
func run(out string) error {
	descriptors, err := get()
	if err != nil {
		return err
	}
	// add reset device
	descriptors = append([]deviceDescriptor{{}}, descriptors...)
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, hdr, deviceDescriptorsURL)
	fmt.Fprintln(buf, "\n// Devices.")
	fmt.Fprintln(buf, "var devices = map[string]device.Info{")
	fmt.Fprintf(buf, `"":{Name:"", UserAgent:"", Width:0, Height:0, Scale:0.000000, Landscape:false, Mobile:false, Touch: false},`+"\n")
	for _, d := range descriptors {
		if d.Name == "" {
			continue
		}
		name := cleanRE.ReplaceAllString(d.Name, "")
		name = strings.ToUpper(name[0:1]) + name[1:]
		if strings.HasSuffix(name, "landscape") {
			name = strings.TrimSuffix(name, "landscape") + "Landscape"
		}
		fmt.Fprintf(buf, `"%s": {Name:%q, UserAgent:%q, Width:%d, Height:%d, Scale:%f, Landscape:%t, Mobile:%t, Touch:%t},`+"\n",
			strings.ToLower(name),
			name, d.UserAgent,
			d.Viewport.Width, d.Viewport.Height, d.Viewport.DeviceScaleFactor,
			d.Viewport.IsLandscape, d.Viewport.IsMobile, d.Viewport.HasTouch,
		)
	}
	fmt.Fprintln(buf, "}")
	src, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}
	return os.WriteFile(out, src, 0o644)
}

var (
	startRE        = regexp.MustCompile(`(?m)^const\s+knownDevices\s*=\s*\[`)
	endRE          = regexp.MustCompile(`(?m)^\] as const;`)
	fixLandscapeRE = regexp.MustCompile(`isLandscape:\s*(true|false),`)
	fixKeysRE      = regexp.MustCompile(`(?m)^(\s+)([a-zA-Z]+):`)
	fixClosesRE    = regexp.MustCompile(`([\]\}]),\n(\s*[\]\}])`)
)

// get retrieves and decodes the device descriptors.
func get() ([]deviceDescriptor, error) {
	res, err := http.Get(deviceDescriptorsURL)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	if res.StatusCode != 200 {
		return nil, fmt.Errorf("got status code %d", res.StatusCode)
	}
	buf, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}
	start := startRE.FindIndex(buf)
	if start == nil {
		return nil, errors.New("could not find start")
	}
	buf = buf[start[1]-1:]
	end := endRE.FindIndex(buf)
	if end == nil {
		return nil, errors.New("could not find end")
	}
	buf = buf[:end[1]-10]
	buf = bytes.Replace(buf, []byte("'"), []byte(`"`), -1)
	buf = fixLandscapeRE.ReplaceAll(buf, []byte(`"isLandscape": $1`))
	buf = fixKeysRE.ReplaceAll(buf, []byte(`$1"$2":`))
	buf = fixClosesRE.ReplaceAll(buf, []byte("$1\n$2"))
	buf = fixClosesRE.ReplaceAll(buf, []byte("$1\n$2"))
	var descriptors []deviceDescriptor
	if err := json.Unmarshal(buf, &descriptors); err != nil {
		return nil, err
	}
	return descriptors, nil
}

const hdr = `
package chrome

// See: %s
` + `// Code generated by devices_gen.go. DO NOT EDIT.` + `

import (
	"github.com/chromedp/chromedp/device"
	"strings"
)

//go:generate go run devices_gen.go

func UserDevice(name string) (device.Info, bool) {
	ret, ok := devices[strings.ToLower(name)]
	return ret, ok
}
`
