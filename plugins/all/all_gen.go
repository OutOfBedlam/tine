//go:build ignore
// +build ignore

package main

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"slices"
)

func main() {
	fout, err := os.OpenFile("all_plugins.go", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		panic(err)
	}
	defer fout.Close()

	out := bufio.NewWriter(fout)
	out.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
	out.WriteString("//go:generate go run all_gen.go\n")
	out.WriteString("\n")
	out.WriteString("package all\n")
	out.WriteString("\n")
	out.WriteString("import (\n")

	for _, path := range []string{".."} {
		gen(path, out)
	}

	out.WriteString(")\n")
	out.WriteString("\nconst A = \"\"\n")
	out.Flush()
}

func gen(path string, out *bufio.Writer) {
	entries, err := os.ReadDir(path)
	if err != nil {
		panic(err)
	}

	matches := []string{}
	for _, ent := range entries {
		for _, pattern := range []string{"*_inlet.toml", "*_outlet.toml", "*_flow.toml", "*_format.toml", "*_compress.toml"} {
			pattern = filepath.Join(path, ent.Name(), pattern)
			if r, err := filepath.Glob(pattern); err != nil {
				fmt.Println("Error:", err)
				return
			} else {
				if len(r) > 0 {
					if !slices.Contains(matches, ent.Name()) {
						matches = append(matches, ent.Name())
					}
				}
			}
		}
	}

	if len(matches) > 0 {
		slices.Sort(matches)
		out.WriteString("\t// plugins\n")
		for _, f := range matches {
			out.WriteString("\t_ \"github.com/OutOfBedlam/tine/plugins/")
			out.WriteString(f)
			out.WriteString("\"\n")
		}
	}
}
